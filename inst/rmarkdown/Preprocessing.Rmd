---
author: "Admin"
date: "24 4 2019"
output:
  html_document:
    df_print: paged
    includes:
      after_body: footer.html
runtime: shiny
params:
  data: ""
  data_to_predict: NULL
  title: ""
  target: ""
  type: TRUE
---

<style type="text/css">
h1.title, h4.date, h4.abstract, p.abstract{
  text-align: center;
}
h1.title{
  margin-top: 30px;
}
h4.abstract{
  margin-top: 50px;
}
.outer{
width: 100%;
}
.scrolltable { margin-top: 20px; height: 600px; overflow: auto; }
.scrolltable table { border-collapse: collapse; }
.scrolltable tr:nth-child(even) { background: #EEE; }
.expand tr:nth-child(even) { background: #EEE; }
#expandButton{
  cursor: pointer;
}
#pipeline{
  background-color: #EEE;
  font-size: 110%;
  padding-bottom: 0px;
  padding-top: 0px;
  border-color: transparent;
  width: fit-content;
}
#section-generations{
  text-align: center;
}
</style>

<script>
var isExpanded = false
function expand() {
  isExpanded ? document.getElementById('section-scrolltable').setAttribute("class", "scrolltable") : document.getElementById('section-scrolltable').setAttribute("class", "expand")
  isExpanded = !isExpanded
}
</script>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require("summarytools")
require("tpotr")
require("mlr")
require("lime")
require("stringr")
require("knitr")
#require(kableExtra)
```

<!-- HEADER SECTION --> 
<div class="container outer">

<div class="row">

<div class="col-sm">

<h1 class="title">`r paste('Automatic report for the dataset:',params$title)`</h1>
<h4 class="date">`r Sys.Date()`</h4>
<h4 class="abstract">Abstract</h4>
<p class="abstract"> This is a report analysing the dataset `r params$title`. </p>
<hr>

</div>

</div>

</div>

<!-- FIRST SECTION --> 

<div class="container outer">

<div class="row">

<div class="col-sm">

<h3>Brief description of the data set</h3>
<p> To confirm that the dataset was loaded correctly, a small summary of the data is given. The dataset has `r ncol(data)` columns and `r nrow(data)` rows. The target column is "`r colnames(data)[length(data)]`" and has `r length(levels(data[,length(data)]))` classes (`r levels(data[,length(data)])`). Therefore, it fits to a classification problem and can be used in this version of the automatic statistician. The table below goes across all the dataset's features. It provides information about the attribute's class, univariate statistics, attribute values, value frequency and value validity. You can <a id = "expandButton" onclick="expand()">expand/collapse</a> the table.</p><br>

<div id="scrolltable" class="scrolltable">

```{r results='asis', echo=FALSE}
data <- data
print(dfSummary(data, plain.ascii = FALSE, style = "grid", graph.magnif = 0.8, headings = FALSE, tmp.img.dir = "/tmp"))
#dfSummary(data, plain.ascii = FALSE, style = "grid")
```

</div>

</div>

</div>

</div>

<!-- SECOND SECTION --> 

<div class="container outer">

<div class="row">

<div class="col-sm">

<h3>Fitting a machine learning pipeline</h3>

```{r echo=FALSE, include=FALSE}
learner <- makeLearner(cl = "classif.tpot", predict.type = "prob", 
                       population_size = 10, generations = 15, 
                       verbosity = 2)
if(type=="classif"){
  task <- makeClassifTask(data = params$data, target = params$target)
} else{
  task <- makeRegrTask(data = params$data, target = params$target)
}
mod <- train(learner, task = task)
pipeline_output <- printPipeline(mod)
pipeline <- gsub("^\\s+|\\s+$", "", sub(".*pipeline:", "", pipeline_output))
generations_list <- lapply(str_extract_all(printPipeline(mod), "score: 0.\\d+"), function(x){
  as.numeric(sub("score: ", "", x))
})
generations <- unlist(generations_list)
```

<p>The Automated Statistician has found a machine learning pipeline, that can predict the target variable in the dataset "`r params$title`". Therefore, it used the TPOT Data Science Assistant R-Version. The best machine learning pipeline is:</p>

<pre id="pipeline">
<code>
`r pipeline`
</code>
</pre>

<p>
To find the best learning pipeline, the TPOT Data Science Assistant created a total of `r length(generations)` generations. The best pipeline has an accurancy of `r max(generations)` for the input training data. Below is a plot which shows how the accuracy developed over the generations.
</p>

<div id="generations">
```{r echo=FALSE}
plot(generations, type="b", xlab="Generations", ylab="CV score", xaxt="n")
axis(1, at = seq(1, 15, by = 1), las=2)
```
</div>

`r if(nrow(params$data_to_predict)){"For the provided test data the pipeline predicted the missing target feature values:"}`
```{r echo=FALSE}
if(nrow(params$data_to_predict) > 0){
  test <- params$data_to_predict[,1:ncol(params$data_to_predict)-1]
  prediction <- predict(obj = mod, newdata = test)$data$response
  kable(cbind(test,prediction))
  #print(performance(pred = prediction, measures=list(acc)))
}
```

</div>

</div>

</div>

<!-- THIRD SECTION --> 

<div class="container outer">

<div class="row">

<div class="col-sm">


<h3>Model explanation</h3>
<p> To enable a model explenation for every possible class 5 different observations were selected. For these 5 observations lime is used to explain the prediction of the model.</p><br>

```{r echo=FALSE}

require("lime")
require("iml")

predictor <- Predictor$new(mod, data=data, y = target)

imp <- FeatureImp$new(predictor, loss = "ce",  compare = "difference")

plot(imp)

mostimp <- imp$results[1,1]

ale <- FeatureEffect$new(predictor, feature = mostimp)

ale$plot()

explainer <- lime(data, mod)

levels <- levels(data[,target])

for(level in levels){
  tempdata <-data[data[,target] == level,]
  explainer <- lime(data, mod)
  explanation <- explain(tempdata[1:5,], explainer, n_labels = 1, n_features = 5)
  print(plot_explanations(explanation))
}
```

</div>

</div>

</div>

